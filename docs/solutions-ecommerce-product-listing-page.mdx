---
id: solutions-ecommerce-product-listing-page
slug: /search-ui/solutions/ecommerce/product-listing-page
title: "Product Listing Page"
description:
date: 2022-07-16
tags: ["Product Listing page", "PLP"]
---

This is a category page:

<DocImage
  url="images/ecommerce/product-listing-page/category-page.png"
  alt="Category page"
/>

At the first glance, category page looks very similar to search page — they both display a list of products and have facets to help users refine the results.
But while search page is made for "searching" the entire catalog by typing a query, category page is mostly made for "exploring" a small subset of products with the help of filters.

In this example, we are only exploring the "Women's Athletic Shoes" section of the catalog.

In this article we will discuss how to implement a product category page.

### Applying Filters to the Product Listing Page

It's important to consider SEO of a category page. Some of your customers will come from search engines and having a good-looking URL will help you rank higher.

Let's say we want to have a category page for TVs. It can be done by taking a general search page and applying a filter to only show TVs.

Now, if we do so on a search page, we'll have a URL like this:

```
mystore.com/search?filters%5B0%5D%5Bfield%5D=categories&filters%5B0%5D%5Bvalues%5D%5B0%5D=TVs
```

Not very readable!

What we want instead is to have a URL like this:

```
mystore.com/category/tvs/
```

To achieve that, we'll need to:

1. Create the category page in our application;
1. Apply a filter via Search UI config.

The first part is highly dependent on your application's framework. Refer to its documentation for creating a new page.

For the second part, take the Search UI config you're using on the search page and add the `searchQuery.filters` value. Then pass the new config to your `SearchProvider`:

```jsx
// import your Search UI config
import { config } from "./config";
import { SearchProvider, WithSearch } from "@elastic/react-search-ui";

const categoryTvsConfig = {
  ...config,
  searchQuery: {
    ...config.searchQuery,
    // adding a filter to only show TVs
    filters: [{ field: "parent_category", values: ["TVs"] }]
  }
};

export default function CategoryPageTvs() {
  return (
    // Pass the new config to SearchProvider
    <SearchProvider config={categoryTvsConfig}>
      <WithSearch mapContextToProps={() => ({})}>
        {() => {
          // The components you want to render go here
        }}
      </WithSearch>
    </SearchProvider>
  );
}
```

That's it! Now the new category page will have a good URL and will only show the results that match the filter.

### Facets

<DocImage
  url="images/ecommerce/product-listing-page/facets.png"
  size="l"
  alt="Facets"
/>

Facets is the most important part of the category page. Since category pages typically don't have their own search box, facets become the main tool to help users find the products they are looking for.

_Facets let users **explore** what's available in your store, rather then **search** for a specific product._

To help users find what they're looking for, it's best to provide a list of facets that are unique to the presented category.

In our example of TVs category page, in addition to common facets, like:

- Price
- Brand
- Rating

we also have TV-specific facets:

- Smart TV _(boolean)_
- TV resolution _(string: "Full HD", "4k", etc.)_
- TV diagonal _(number)_

These TV-specific facets are not useful on the search page, since they are not relevant to most of the results.

---

There are several ways to implement this in Search UI. They offer different levels of control and flexibility.

1. All category pages share a single config. This is the simplest option to implement but it's also least flexible and least performant.
1. All category pages share a single config, but the facets are shown conditionally. This is a middle ground in terms of simplicity and flexibility and as performant as the next option.
1. Each category page uses it's own config. This is the most flexible and most performant option but it requires more work to implement.

#### Single config

It is possible to use a single Search UI config on the search page and all category pages. This comes with a performance drawback: the facets data will be requested on every page even if it's not going to be used. The decision is up to you: single config will work as well as separate configs if most of your documents share the same properties.

To implement this, you'll need to:

1. Add new result fields to `searchQuery.resultFields`
1. Add new facets to `searchQuery.facets`
1. (optional) Add new disjunctiveFacets `searchQuery.disjunctiveFacets`

Then, add the `Facet` components to UI.

The result code will look something like this:

```jsx
// import your Search UI config
import { SearchProvider, WithSearch } from "@elastic/react-search-ui";

const config = {
  searchQuery: {
    // 1. Adding new resilt fields, these will be used for the facets
    result_fields: {
      tv_size: { raw: {} },
      tv_smart_tv: { raw: {} },
      tv_resolution: { raw: {} }
      // some other fields
    },
    // 2. Adding the new facets
    facets: {
      tv_size: {
        type: "value",
        sort: { value: "asc" }
      },
      tv_smart_tv: {
        type: "value"
      },
      tv_resolution: {
        type: "value",
        sort: { value: "asc" }
      }
      // some other facets
    },
    // 3. Making some of newly added facets disjunctive
    disjunctiveFacets: ["tv_size", "tv_resolution"]
  }
};

export default function CategoryPage() {
  return (
    // Pass the config to SearchProvider
    <SearchProvider config={config}>
      <WithSearch mapContextToProps={() => ({})}>
        {() => {
          return (
            // The components you want to render go here
            // For the sake of brevity, we're only showing the new facets
            <>
              <Facet field="tv_smart_tv" label="Smart TV" view={BooleanFacet} />
              <Facet field="tv_resolution" label="Resolution" />
              <Facet field="tv_size" label="Diagonal size" />
            </>
          );
        }}
      </WithSearch>
    </SearchProvider>
  );
}
```

#### Conditional facets

Search UI allows you to show facets conditionally based on the applied filters.
Follow the main guide for more info and code examples: <DocLink id="guides-conditional-facets" text="Conditional facets" />.

#### Each category page uses it's own config

This option closely follows the single config option, but requires you to make a copy of the main Search UI config (that you use on the search page) first.

1. Import and make a copy of the main Search UI config
1. Add new result fields to `searchQuery.resultFields`
1. Add new facets to `searchQuery.facets`
1. (optional) Add new disjunctiveFacets `searchQuery.disjunctiveFacets`

Then, add the `Facet` components to UI.

Here's how to do it all at once:

```jsx
// import your Search UI config
import { config } from "./config";
import { SearchProvider, WithSearch } from "@elastic/react-search-ui";

const categoryTvsConfig = {
  ...config,
  searchQuery: {
    ...config.searchQuery,
    filters: [{ field: "parent_category", values: ["TVs"] }],
    // 1. Adding new resilt fields, these will be used for the facets
    result_fields: {
      ...config.searchQuery.result_fields,
      tv_size: { raw: {} },
      tv_smart_tv: { raw: {} },
      tv_resolution: { raw: {} }
    },
    // 2. Adding the new facets
    facets: {
      ...config.searchQuery.facets,
      tv_size: {
        type: "value",
        sort: { value: "asc" }
      },
      tv_smart_tv: {
        type: "value"
      },
      tv_resolution: {
        type: "value",
        sort: { value: "asc" }
      }
    },
    // 3. Making some of newly added facets disjunctive
    disjunctiveFacets: [
      ...config.searchQuery.disjunctiveFacets,
      "tv_size",
      "tv_resolution"
    ]
  }
};

export default function CategoryPageTvs() {
  return (
    // Pass the new config to SearchProvider
    <SearchProvider config={categoryTvsConfig}>
      <WithSearch mapContextToProps={() => ({})}>
        {() => {
          return (
            // The components you want to render go here
            // For the sake of brevity, we're only showing the new facets
            <>
              <Facet field="tv_smart_tv" label="Smart TV" view={BooleanFacet} />
              <Facet field="tv_resolution" label="Resolution" />
              <Facet field="tv_size" label="Diagonal size" />
            </>
          );
        }}
      </WithSearch>
    </SearchProvider>
  );
}
```

---

Search UI offers several kinds of facets out-of-the-box:

- MultiCheckboxFacet
- BooleanFacet
- SingleLinksFacet

Here's an example of how to use them and the resulting UI:

```jsx
import { BooleanFacet, SingleLinksFacet } from "@elastic/react-search-ui-views";

<Facet
  field="tv_smart_tv"
  label="Smart TV"
  view={BooleanFacet}
/>
<Facet
  field="tv_resolution"
  label="Resolution"
  view={SingleLinksFacet}
/>
<Facet
  field="tv_size"
  label="Diagonal size"
  filterType="any" // accepts "all", "any" and "none"
  // Using the default view={MultiCheckboxFacet}
/>
```

<DocImage
  url="images/ecommerce/product-listing-page/facet-views.png"
  size="l"
  alt="Facet views"
/>

### Filters

Examples for ecommerce product listing page

- pricing range filter

### Variant Examples

You might have several products that are essentially the same, but have one different attribute. The most popular example of it is color of a shirt or a smartphone. In our example, it's the same TV models but with different diagonals.

If you have such products in your store, it could be better to combine them into a single result. That will prevents users from being overwhelmed by the number of options.

To implement this in Search UI, you'll need to do the following:

1. Enrich your dataset.
2. Enable grouping in Search UI config.
3. Add varians rendering into your Result component.

#### Enriching dataset

For each document in your dataset, add a new field that will later be used for grouping search results. Here's the example:

```json
[
  {
    "name": "Samsung TV 55 inch",
    "product_group": "[GROUP_ID_1]"
  },
  {
    "name": "Samsung TV 45 inch",
    "product_group": "[GROUP_ID_1]"
  },
  {
    "name": "LG TV 55 inch",
    "product_group": "[GROUP_ID_2]"
  }
]
```

Make sure to add that new field to all the documents in a dataset! Otherwise, the documents that are missing this field will be combined into a single group.

#### Enabling grouping in Search UI config

The grouping is not directly supported by Search UI, but it is supported by the underlying [App Search API](https://www.elastic.co/guide/en/app-search/current/grouping.html).
So instead of enabling it in Search UI config, we'll enable it in App Search connector config.
Here's an example:

```js
const connector = new AppSearchAPIConnector({
  searchKey: "search-key",
  engineName: "engine-name",
  endpointBase: "endpointBase",
  // enabling grouping in App Search connector config
  beforeSearchCall: (existingSearchOptions, next) =>
    next({
      ...existingSearchOptions,
      group: { field: "product_group", collapse: true }
    })
});

export const config = {
  alwaysSearchOnInitialLoad: true,
  apiConnector: connector
  // other config properties
};
```

#### Adding varians rendering into your Result component

Once you have the grouping enabled, the variants will be available via the `_group` field in your result document.
Here's a simplified example of how to use it:

```jsx
{
  result._group && result._group.length > 0 && (
    <ul>
      {result._group.map((variant) => (
        <li>
          <a href={variant.url.raw} target="_blank">
            <span dangerouslySetInnerHTML={{ __html: variant.name.snippet }} />
          </a>
        </li>
      ))}
    </ul>
  );
}
```

### Sorting

<DocImage
  url="images/ecommerce/product-listing-page/sorting.png"
  size="l"
  alt="Sorting component"
/>

Adding sorting is simple — just use our `<Sorting/>` component, like so:

```js
import { Sorting } from "@elastic/react-search-ui";

<Sorting
  label={"Sort by"}
  sortOptions={[
    {
      name: "Relevance",
      value: []
    },
    {
      name: "Price: Low to High",
      value: [{ field: "price", direction: "asc" }]
    },
    {
      name: "Price: High to Low",
      value: [{ field: "price", direction: "desc" }]
    }
  ]}
/>;
```

A good starting point for sorting options is to have these three:

- Relevance / Featured / Best Match (usually the default option)
- Price: Low to High
- Price: High to Low

Also consider adding some of these if they are applicable to your data:

- Popularity
- User rating
- Distance (to user)
- Newest first
